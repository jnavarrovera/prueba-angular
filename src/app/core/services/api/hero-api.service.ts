import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { ApiService } from '@core/interfaces/api-service.interface';
import { Pagination } from '@core/interfaces/pagination.interface';
import { ControlatedError } from '@core/models/controlated-error.model';
import { Hero } from '@core/models/hero.model';
import { environment } from '@env/environment';
import { Observable, map } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class HeroApiService implements ApiService<Hero> {
  constructor(private http: HttpClient) {}
  readonly api: string = `${environment.api_server}/heroes`;

  list(
    param?: any
  ): Observable<{ data: Hero[]; pagination?: Pagination | undefined }> {
    return this.http.get<Hero[]>(this.api).pipe(
      map((resp) => {
        let data = resp.map((hero) => new Hero(hero));
        const total = data.length;
        // This kind of logic must be in backend.
        data = param?.name
          ? data.filter((hero) =>
              hero.name.toLowerCase().includes(param.name.toLowerCase())
            )
          : data;

        const per_page = param?.per_page ?? 10;
        const current_page = param?.current_page >= 1 ? param?.current_page : 1;

        data = data.slice(
          (current_page - 1) * per_page,
          current_page * per_page
        );

        return {
          data,
          pagination: { total, per_page, current_page },
        };
      })
    );
  }

  get(id: number): Observable<Hero> {
    return this.http.get<Hero[]>(this.api).pipe(
      map((resp) => {
        const hero = resp.find((hero) => hero.id === id);
        if (!hero) {
          throw new ControlatedError(
            'Héore no encontrado',
            'message',
            'El héroe no existe'
          );
        }
        return hero;
      })
    );
  }

  create(data: Hero): Observable<Hero> {
    data.id = new Date().getTime(); // Simulates autogenerated Id
    return this.http
      .post(this.api, data.serialize())
      .pipe(map((resp) => new Hero(resp)));
  }

  delete(data: Hero): Observable<void> {
    return this.http
      .delete<void>(`${this.api}/${data.id}`)
      .pipe(map((resp) => resp));
  }

  update(data: Hero): Observable<Hero> {
    return this.http
      .patch(`${this.api}/${data.id}`, data.serialize())
      .pipe(map((resp) => new Hero(resp)));
  }
}
